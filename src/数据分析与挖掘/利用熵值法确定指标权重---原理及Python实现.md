#背景
在进行一些综合评估类项目时，需要给一些指标确定一个合理的权重，用来计算综合得分，这种综合评估类项目在实际的业务中有很多应用，比如：学生奖学金评定方法、广告效果综合评估、电视节目满意度综合评估、用户满意度综合评估等。计算权重的方法比较多，下面主要介绍利用熵值法来确定权重。
#一些名词解释
* 个案
一个个案，一条记录，也就是一个样本，在矩阵里面就是一行数据，不同地方叫法不一样
* 属性
属性就是样本所拥有的特性，也就是特征，在矩阵里面就是一列数据



#熵值法概念
>熵值法原理： 熵的概念源于热力学，是对系统状态不确定性的一种度量。在信息论中，信息是系统有序程度的一种度量。而熵是系统无序程度的一种度量，两者绝对值相等，但符号相反。根据此性质，可以利用评价中各方案的固有信息，通过熵值法得到各个指标的信息熵，**信息熵越小，信息的无序度越低，其信息的效用值越大，指标的权重越大**。

熵是不确定性的度量，如果用$P_{i}$表示第$i$个信息的不确定度（也就是出现的概率），则整个信息（设有$n$个）的不确定度量如下所示：
$$S=-K\sum_{i=1}^{n}P_{i}lnP_{i}$$ 
这就是熵，其中$K$为正常数，当各个信息发生的概率相等时，即$P_{i}=\frac{1}{n}$，$S$取值最大，此时熵最大，也就是信息无序度最大，各个信息都发生可能性一样
# 熵值法步骤
- 1. 可利用信息熵的概念确定权重，假设多属性决策矩阵如下：
$$M=
\begin{matrix}
A_{1}  \\
A_{2}  \\
\vdots  \\
A_{n} \end{matrix} 
\left[
\begin{matrix}
x_{11} & x_{12} & \cdots &  x_{1m}\\
x_{21} & x_{22} & \cdots &  x_{2m}\\
\vdots & \vdots & \ddots & \vdots \\
x_{n1} & x_{n2} & \cdots & x_{nm}
\end{matrix}\right] $$
则用$P_{ij}=\frac{x_{ij}}{\sum_{i=1}^{ n}x_{ij}}$  表示第$j$个属性下第$i$个方案$A_{i}$的贡献度

- 2. 可以用$E_j$来表示所有方案对属性$X_j$的总贡献度：
$$E_j=-K\sum_{i=1}^{n}P_{ij}lnP_{ij}$$ 其中，常数$K=\frac{1}{ln(n)}$，这样，就能保证$0=<E_j<=1$，即$E_j$最大1。
由式中可以看出，当某个属性各个方案（样本）的贡献度趋于一致时，$E_j$趋于1。<br/>
**那么各个方案（样本）的贡献度全相等时，就应该不考虑该属性在决策中的作用，也就是该属性的权重应该为0**

- 3. 这样可以看出属性的权重系数大小由各方案差异大小来决定，为此可定义$d_j$为第$j$属性的各方案贡献度的一致性程度
$$d_j=1-E_j$$
- 4. 进行归一化后，各属性权重如下：
$$W_j=\frac{d_j}{\sum_{j=1}^{m}d_j}$$当$d_j=0$时，第$j$属性可以剔除，其权重等于0
- 5. 如果决策者事先已有一些经验的主观估计权重$\lambda_j$，则可借助上述的$W_j$来对$\lambda_j$进行修正
$$W_{j}^{*}=\frac{\lambda_j W_j}{\sum_{j=1}^{m}\lambda_j W_j}$$

**熵值法最大的特点是直接利用决策矩阵所给出的信息计算权重，而没有引入决策者的主观判断，完全是依靠数据来决定**

#案例
购买汽车的一个决策矩阵，给出了四个方案供我们进行选择，每个方案中均有相同的六个属性，我们需要利用熵值法求出各属性的权重

车型 | 油耗 | 功率 | 费用 | 安全性 | 维护性 | 操作性
:-:|:-:|:-:|:-:|:-:|:-:|:-:
本田|5|1.4|6|3|5|7
奥迪|9|2|30|7|5|9
桑塔纳|8|1.8|11|5|7|5
别克|12|2.5|18|7|5|5
#####计算步骤
- 1. 求第$j$个属性下第$i$个方案$A_i$的贡献度，公式为:
$$P_{ij}=\frac{x_{ij}}{\sum_{i=1}^{ n}x_{ij}}$$在excel中的话，先求出各列的和，然后用每行的数值比上列和，形成新的矩阵

车型 | 油耗 | 功率 | 费用 | 安全性 | 维护性 | 操作性
:-:|:-:|:-:|:-:|:-:|:-:|:-:
本田|5|1.4|6|3|5|7
奥迪|9|2|30|7|5|9
桑塔纳|8|1.8|11|5|7|5
别克|12|2.5|18|7|5|5
**总计**|**34**|**7.7**|**65**|**22**|**22**|**26**

**$P$矩阵：**
车型 | 油耗 | 功率 | 费用 | 安全性 | 维护性 | 操作性
:-:|:-:|:-:|:-:|:-:|:-:|:-:
本田|5/34|1.4/7.7|6/65|3/22|5/22|7/26
奥迪|9/34|2/7.7|30/65|7/22|5/22|9/26
桑塔纳|8/34|1.8/7.7|11/65|5/22|7/22|5/26
别克|12/34|2.5/7.7|18/65|7/22|5/22|5/26
<br/>
- 2. 求出所有方案对属性$X_j$的贡献总量，公式为:
$$E_j=-K\sum_{i=1}^{n}P_{ij}lnP_{ij}$$
在excel操作中，将刚才生成的矩阵每个元素变成每个元素与该元素自然对数的乘积
<br/>

***只列出油耗计算过程，其他属性同理***

车型 | 油耗
:-:|:-:
本田|5/34 * ln(5/34)
奥迪|9/34 * ln(9/34)
桑塔纳|8/34 * ln(8/34)
别克|12/34 * ln(12/34)
**总计**|5/34* ln(5/34) + 9/34* ln(9/34) + 8/34* ln(8/34) + 12/34* ln(12/34)

求出常数$k$，$k$为$1/ln(方案数)$，本例中有4个方案，所以求得$k$为$1/ln(4)$，再求$k$与新矩阵每一列和的乘积，这样获得的 6 个积为所有方案对属性$x_j$的贡献度
车型 | 油耗
:-:|:-:
本田|5/34 * ln(5/34)
奥迪|9/34 * ln(9/34)
桑塔纳|8/34 * ln(8/34)
别克|12/34 * ln(12/34)
**总计**|5/34* ln(5/34) + 9/34* ln(9/34) + 8/34* ln(8/34) + 12/34* ln(12/34)
**$E_j$**|1/ln(4)  *  [ 5/34* ln(5/34) + 9/34* ln(9/34) + 8/34* ln(8/34) + 12/34* ln(12/34) ]

至此所有的$E_j$就求出来了
<br/>
- 3. $d_j$为第$j$属性下各方案贡献度的一致性程度，公式为：
$$d_j=1-E_j$$利用上面求得的$E_j$，可以得到$d_j$

车型 | 油耗
:-:|:-:
本田|5/34 * ln(5/34)
奥迪|9/34 * ln(9/34)
桑塔纳|8/34 * ln(8/34)
别克|12/34 * ln(12/34)
**总计**|5/34* ln(5/34) + 9/34* ln(9/34) + 8/34* ln(8/34) + 12/34* ln(12/34)
**$E_j$**|1/ln(4)  *  [ 5/34* ln(5/34) + 9/34* ln(9/34) + 8/34* ln(8/34) + 12/34* ln(12/34) ]
**$d_j$**|1 - 1/ln(4) * [5/34* ln(5/34) + 9/34* ln(9/34) + 8/34* ln(8/34) + 12/34* ln(12/34) ]
- 4. 利用下面公式进行归一化后，即可求得各属性的权重：
$$W_j=\frac{d_j}{\sum_{j=1}^{m}d_j}$$

经过计算后各属性的权重为：
车型 | 油耗 | 功率 | 费用 | 安全性 | 维护性 | 操作性
:-:|:-:|:-:|:-:|:-:|:-:|:-:
**权重**|**0.14**|**0.07**|**0.49**|**0.16**|**0.04**|**0.10**
所以在购买汽车时，据所提供信息，利用熵值法计算得出的权重为油耗占 14%，功率占 7%，费用占 49%，安全性占 16%，维护性占 4%，操作性占 10%。故我们在进行购买决策时，更多是考虑车型的价格和安全性等重要因素，这是从权重角度考虑的。

#利用Python实现熵值法：
***代码如下：***
```python
import pandas as pd
import numpy as np
import math
from numpy import array

# 定义熵值法函数  熵值法计算变量的权重
def cal_weight(df):
    #求k
    rows = df.index.size  # 行
    cols = df.columns.size  # 列
    k = 1.0 / math.log(rows)

    # 矩阵计算、信息熵
    x = array(df)
    lnf = [[None] * cols for i in range(rows)]
    lnf = array(lnf)
    for i in range(0, rows):
        for j in range(0, cols):
            if x[i][j] == 0:
                lnfij = 0.0
            else:
                p = x[i][j] / np.sum(x, axis=0)[j]
                lnfij = math.log(p) * p * (-k)
            lnf[i][j] = lnfij
    lnf = pd.DataFrame(lnf)
    E = lnf

    # 计算一致性程度
    d = 1 - E.sum(axis=0)

    # 计算各指标的权重
    w = [[None] * 1 for i in range(cols)]
    for j in range(0, cols):
        wj = d[j] / sum(d)
        w[j] = wj

    w = pd.DataFrame(w)
    w.index = df.columns
    w.columns = ['权重']
    
    return w
```
